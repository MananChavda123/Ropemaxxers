#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <map>
#include <sstream>
#include<math.h>
using namespace std;

class core {
public:
    long long int x[32];
    int na=0;
    int destination,value; 
    int pc, size;
    bool isStall;
    int stalls;
    vector<string> newmemory;
    string instruction;
    vector<string> decodedinstruction;
    std::string filename1;
    map<string, int> mnew;

        core(const std::string& filename) : filename1(filename), pc(0), size(0) {
        pc = 0;
        stalls = 0;
        isStall = false;
        destination=0;
        value=0;
        ifstream infile(filename1);
        string t;
        instruction="temp";
        for (int i = 0; i < 32; i++) {
            x[i] = 0;
        }
        while (getline(infile, t)) {
            newmemory.push_back(t);
            pc = pc + 1;
            string newi = "";
            for (char c : t) {
                if (c == ':') {
                    mnew.insert({ newi, pc });
                }
                else {
                    newi = newi + c;
                }
            }
        }
        size = pc;
        infile.close();
        pc = 0;
    }

    string independentInstructionFetch() {
        // cout<<"fetch"<<newmemory[pc]<<" ";
        if (pc >= newmemory.size()) {
            return ""; 
        }
        string instruction = newmemory[pc];
        pc++;
        return instruction;
    }

    vector<string> independentInstructionDecode(string& instruction) {
        vector<string> v;
        // cout<<"decode"<<instruction;
        // cout<<endl;
        if(instruction.empty()){
        }
        else{
            string token;
            for (char c : instruction) {
                if (c != ' ') {
                    token += c;
                }
                else {
                    v.push_back(token);
                    token.clear();
                }
            }
            if (!token.empty()) {
                v.push_back(token);
            }
            return v;
        }

    }
bool detectDataHazardStall() {
    if(pc+1 < newmemory.size()){
    string nextInstruction = newmemory[pc];
    string nextInstruction1 = newmemory[pc+1];
    vector<string> v1,v2;
        // cout<<"decode"<<instruction;
        // cout<<endl;S
        if(nextInstruction.empty()){

        }
        else{
            string token;
            for (char c : nextInstruction) {
                if (c != ' ') {
                    token += c;
                }
                else {
                    v1.push_back(token);
                    token.clear();
                }
            }
            if (!token.empty()) {
                v1.push_back(token);
            }
        }
            string opcode = v1[0];
            
    if (opcode == "add" || opcode == "sub" || opcode == "addi" || opcode == "slli" || opcode == "srli"){
        int rd = stoi(v1[1].substr(1));    
        v1.clear();
        if(nextInstruction1.empty()){
        }
        else{
            string token;
            for (char c : nextInstruction1) {
                if (c != ' ') {
                    token += c;
                }
                else {
                    v1.push_back(token);
                    token.clear();
                }
            }
            if (!token.empty()) {
                v1.push_back(token);
            }
        }
            if (opcode == "add" || opcode == "sub"){
                if(rd == stoi(v1[1].substr(1)) || rd == stoi(v1[2].substr(1)) ||  rd == stoi(v1[3].substr(1))){
                    isStall = true;
                    stalls++;
                    return true;
                }
            }
            else if (opcode == "addi" || opcode == "slli" || opcode == "srli"){
                // if(rd == stoi(v1[1].substr(1)) ||  rd == stoi(v1[2].substr(1))){
                //     isStall = true;
                //     stalls++;
                //     return true;
                // }
            }
        }
    }
    return false; 
}

bool dataHazardDetected(const core& currentCore, const vector<string>& nextDecodedInstruction) {
    // Check if the next instruction uses any of the registers written by the current instruction
    // for (int i = 1; i < nextDecodedInstruction.size(); ++i) {
    //     if (nextDecodedInstruction[i][0] == 'x') {
    //         int reg = stoi(nextDecodedInstruction[i].substr(1));
    //         if (reg < 32 && reg >= 0) {
    //             if (currentCore.x[reg] != 0) {
    //                 return true; // Data hazard detected
    //             }
    //         }
    //     }
    // }
    return false;
}

bool controlHazardDetected(const vector<string>& nextDecodedInstruction) {
    // Check if the next instruction is a branch instruction
    if (nextDecodedInstruction.size() > 0) {
        string opcode = nextDecodedInstruction[0];
        if (opcode == "bne" || opcode == "bgt" || opcode == "blt" || opcode == "bge" || opcode == "ble" || opcode == "beq" || opcode == "j" || opcode == "jump") {
            return true; // Control hazard detected
        }
    }
    return false;
}
void independentExecute(vector<string>& v,int *memory){
    // cout<<"execute";
    for(int i=0;i<v.size();i++){
        // cout<<v[i];
    }
    cout<<endl;
    map<string, long long int> n;
    string addressAdder="";
    string temp="";
    int t=0;
    int offset=0;
    if(v.empty()){

    }
    else{
        string opcode = v[0];
        if (opcode == "add" || opcode == "sub" || opcode == "addi" || opcode == "slli" || opcode == "srli") {
            int rd = stoi(v[1].substr(1));
            destination = rd;
            int rs1 = stoi(v[2].substr(1));
            if (opcode == "add") {
                value = x[rs1] + x[stoi(v[3].substr(1))];
            } else if (opcode == "sub") {
                value = x[rs1] - x[stoi(v[3].substr(1))];
            } else if (opcode == "addi") {
                value = x[rs1] + stoi(v[3]);
            } else if (opcode == "slli") {
                value = x[rs1] << stoi(v[3]);
            } else if (opcode == "srli") {
                value = x[rs1] >> stoi(v[3]);
            }
            v.clear();
        } 

        else if (opcode == "bne" || opcode == "beq" || opcode == "bgt" || opcode == "blt" || opcode == "bge" || opcode == "ble") {
            int rd = stoi(v[1].substr(1));
            int rs1 = stoi(v[2].substr(1));
            string label = v[3];
            if ((opcode == "bne" && x[rd] != x[rs1]) ||
                (opcode == "beq" && x[rd] == x[rs1]) ||
                (opcode == "bgt" && x[rd] > x[rs1]) ||
                (opcode == "blt" && x[rd] < x[rs1]) ||
                (opcode == "bge" && x[rd] >= x[rs1]) ||
                (opcode == "ble" && x[rd] <= x[rs1])) {
                isStall=true;
                pc = mnew[label];
            }
            v.clear();
        }

    else if(opcode == "j" || opcode == "jump"){
        string label;
        label = v[1];
        isStall=true;
        v.clear();
        jump(label);
        return;
    } 
    if(opcode==".data") {
        pc = pc - 1;
            while(pc < newmemory.size() && newmemory[pc] != ".text"){                
                string line1 = newmemory[pc];
                // cout<<line1;
                string opcode1, opcode2;
                std::istringstream iss1(line1);
                iss1 >> opcode1 >>opcode2;              
                // cout<<opcode1<<" "<<opcode2;
                if(opcode2==".word"){
                    int count=0;
                    int x;
                    int memsize = 0;
                    for(int i=0; i<1024; i++){
                        if(i==0){
                             long long int lang = reinterpret_cast< long long int>(memory);
                        }
                        if(memory[i]!=0){
                            memsize++;
                        }

                    }
                    while(iss1 >> x){ 
                        memory[count] = x;
                        count++;
                    }
                }
                pc++;
            }    
        } 
    }
    v.clear();
}
void independentMemory(vector<string> &v,int memory[]){

    if(v.empty()){

    }
    else{
            cout<<"memory";
    for(int i=0;i<v.size();i++){
        cout<<v[i];
    }
    cout<<endl;
    // map<string, long long int> n;
    string addressAdder="";
    string temp="";
    int t=0;
    int offset=0;
    string opcode = v[0];
    if (opcode == "lw") {
        // cout<<v[2]<<endl;
        int rd = stoi(v[1].substr(1));
        addressAdder=v[2];
              if(!isdigit(v[2][0])){
                
                    x[rd] =  reinterpret_cast< long long int>(memory);
                    cout<<x[rd]<<endl;
                }
                else{
        for(char d : addressAdder){
            if(isdigit(d)){
                temp+=d;
            }
            else{
                break;
            }
        }
        offset = stoi(temp);
        temp="";
        for(char d : addressAdder){
            if(d=='x'){
                temp+=d;
                t=1;
            }
            if(t==1){
               if(isdigit(d)){
                    temp+=d;
                } 
            }
        }
        int rs1 = stoi(temp.substr(1));
        int* array_ptr = reinterpret_cast<int*>(x[rs1]+offset);
        x[rd] = *array_ptr;
        cout<<" "<<x[rd]<<" "<<x[rs1]+offset<<endl;
                }

        temp="";t=0;
    } 
    else if (opcode == "la") {
        int rd = stoi(v[1].substr(1));
        addressAdder=v[2];
              if(!isdigit(v[2][0])){
                
                    x[rd] =  reinterpret_cast< long long int>(memory);
                    // cout<<x[rd]<<endl;
                }
                else{
        for(char d : addressAdder){
            if(isdigit(d)){
                temp+=d;
            }
            else{
                break;
            }
        }
        offset = stoi(temp);
        temp="";
        for(char d : addressAdder){
            if(d=='x'){
                temp+=d;
                t=1;
            }
            if(t==1){
               if(isdigit(d)){
                    temp+=d;
                } 
            }
        }
        int rs1 = stoi(temp.substr(1));
            
        int* array_ptr = reinterpret_cast<int*>(x[rs1]+offset);
        x[rd] = *array_ptr;
        // cout<<" "<<x[rd]<<" "<<x[rs1]<<endl;
                }

        temp="";t=0;
    } 
    else if (opcode == "sw") {
         int rd = stoi(v[1].substr(1));
        addressAdder = v[2];
        for (char d : addressAdder) {
            if (isdigit(d)) {
                temp += d;
            } else {
                break;
            }
        }
        offset = stoi(temp);
        temp = "";
        for (char d : addressAdder) {
            if (d == 'x') {
                temp += d;
                t = 1;
            }
            if (t == 1) {
                if (isdigit(d)) {
                    temp += d;
                }
            }
        }
        int rs1 = stoi(temp.substr(1));
        int* memory_ptr = reinterpret_cast<int*>(x[rs1] + offset);
        *memory_ptr = x[rd];
        temp = "";
        t = 0;
    }
    return;  
    }

}

void independentWriteBack(){
    x[destination] = value;
    destination = 0;
    value = 0;
    return;
}
int one_cycle(int memory[]){
    if(detectDataHazardStall()){
        independentWriteBack();
        independentMemory(decodedinstruction,memory);
        
        
        
        if(!isStall){
            independentExecute(decodedinstruction,memory);
            decodedinstruction = independentInstructionDecode(instruction);
            if(instruction.empty()){
                return 1;
            }
        instruction =  independentInstructionFetch();
        }
        
    }
    else{
        independentWriteBack();
        independentMemory(decodedinstruction,memory);
        independentExecute(decodedinstruction,memory);
        
        
        if(!isStall){
            decodedinstruction = independentInstructionDecode(instruction);
        }
        if(instruction.empty()){
                return 1;
            }
        instruction =  independentInstructionFetch();
    }
        
        isStall=false;
}

    void jump(const string& label) {
        isStall=true;
        pc = mnew[label];
    }
};


class processor {
private:
    std::vector<core> cores;
    int *memory;
    int clock;
    int clock1;
    vector<string> decodedInstruction;

public:
    processor() {
        memory = new int[1024];
        cores.push_back(core("C:/Users/havis/OneDrive/Desktop/Project/test1.asm"));//choose path from the provided files
        cores.push_back(core("C:/Users/havis/OneDrive/Desktop/Project/test2.txt"));//choose path from the provided files
        clock = 0;
        clock1 = 0;
    }

    void independentRun() {
        while (true) {
            
            if(cores[0].one_cycle(memory) == 1 ){
                break;
            }
            clock=clock+1;
        }
        for(int i=0;i<1024;++i){
            cout<<memory[i]<<" ";
        }
        cout<<endl;
        for(int i =0;i<32;++i){
            cout<<cores[0].x[i]<<" ";
        }
        cout<<"the no. of clock cycle is:"<<clock;
    }
};

int main() {
    processor p;
    p.independentRun(); // Start the execution of the processor
    return 0;
}
