#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <map>
#include <sstream>
using namespace std;

class core {
public:
    long long int x[32]; 
    int pc, size;
    vector<string> newmemory;
    std::string filename1 = "C:/Users/Manan/Desktop/Manan/code.txt";
    map<string, int> mnew;

    core() {
        pc = 0;
        ifstream infile(filename1);
        string t;
        for (int i = 0; i < 32; i++) {
            x[i] = 0;
        }
        while (getline(infile, t)) {
            newmemory.push_back(t);
            pc = pc + 1;
            string newi = "";
            for (char c : t) {
                if (c == ':') {
                    mnew.insert({ newi, pc });
                }
                else {
                    newi = newi + c;
                }
            }
        }
        size = pc;
        infile.close();
        pc = 0;
    }

    string independentInstructionFetch() {
        // cout<<newmemory[pc]<<endl;
        if (pc >= newmemory.size()) {
            return ""; 
        }
        string instruction = newmemory[pc];
        pc++;
        return instruction;
    }

    // Independent instruction decode method
    vector<string> independentInstructionDecode(const string& instruction) {
        vector<string> v;
        string token;
        for (char c : instruction) {
            if (c != ' ') {
                token += c;
            }
            else {
                v.push_back(token);
                token.clear();
            }
        }
        if (!token.empty()) {
            v.push_back(token);
        }
        return v;
    }

void independentExecute(vector<string>& v,int *memory){
    map<string, long long int> n;
    string opcode = v[0];
    string addressAdder="";
    string temp="";
    int t=0;
    int offset=0;
    if (opcode == "add") {
        int rd = stoi(v[1].substr(1));
        int rs1 = stoi(v[2].substr(1));
        int rs2 = stoi(v[3].substr(1));
        x[rd] = x[rs1] + x[rs2];
    } 
    else if (opcode == "sub") {
        int rd = stoi(v[1].substr(1));
        int rs1 = stoi(v[2].substr(1));
        int rs2 = stoi(v[3].substr(1));
        x[rd] = x[rs1] - x[rs2];
    } 
    else if (opcode == "addi") {
        int rd = stoi(v[1].substr(1));
        int rs1 = stoi(v[2].substr(1));
        int imm = stoi(v[3]);
        x[rd] = x[rs1] + imm;
        // cout<<x[rd];
    }
    else if (opcode == "lw") {
        // cout<<v[2]<<endl;
        int rd = stoi(v[1].substr(1));
        addressAdder=v[2];
              if(!isdigit(v[2][0])){
                
                    x[rd] =  reinterpret_cast< long long int>(memory);
                    cout<<x[rd]<<endl;
                }
                else{
                            for(char d : addressAdder){
            if(isdigit(d)){
                temp+=d;
            }
            else{
                break;
            }
        }
        offset = stoi(temp);
        temp="";
        for(char d : addressAdder){
            if(d=='x'){
                temp+=d;
                t=1;
            }
            if(t==1){
               if(isdigit(d)){
                    temp+=d;
                } 
            }
        }
        
        int rs1 = stoi(temp.substr(1));
        x[rs1] = reinterpret_cast< long long int>(memory) ;
        cout<<memory[0]<<endl;
         long long int xavi=x[rs1]+offset;
        int* array_ptr = reinterpret_cast<int*>(xavi);
        x[rd] = *array_ptr;
                }
 
        temp="";t=0;
    } 
    else if (opcode == "sw") {
        int rd = stoi(v[1].substr(1));
        addressAdder = v[2];
        for (char d : addressAdder) {
            if (isdigit(d)) {
                temp += d;
            } else {
                break;
            }
        }
        offset = stoi(temp);
        temp = "";
        for (char d : addressAdder) {
            if (d == 'x') {
                temp += d;
                t = 1;
            }
            if (t == 1) {
                if (isdigit(d)) {
                    temp += d;
                }
            }
        }
        int rs1 = stoi(temp.substr(1));
        int* memory_ptr = reinterpret_cast<int*>(x[rs1] + offset);
        *memory_ptr = x[rd];
        temp = "";
        t = 0;
    }

    else if (opcode == "bne") {
        int rd = stoi(v[1].substr(1));
        int rs1 = stoi(v[2].substr(1));
        
        if(x[rd] != x[rs1]){
            string label;
            label = v[3];
            jump(label);
            return;
        }
        // else{
        //     cout<<"lund";
        // }
        v.clear();
    } 
     else if (opcode == "bgt") {
        int rd = stoi(v[1].substr(1));
        int rs1 = stoi(v[2].substr(1));
        
        if(x[rd] > x[rs1]){
            string label;
            label = v[3];
            jump(label);
            return;
        }
        // else{
        //     cout<<"lund";
        // }
    } 
    else if (opcode == "bge") {
        int rd = stoi(v[1].substr(1));
        int rs1 = stoi(v[2].substr(1));
        
        if(x[rd] >= x[rs1]){
            string label;
            label = v[3];
            jump(label);
            return;
        }
        // else{
        //     cout<<"lund";
        // }
    } 
    else if (opcode == "beq") {
        // cout<<"lund";
        int rd = stoi(v[1].substr(1));
        int rs1 = stoi(v[2].substr(1));
        
        if(x[rd] == x[rs1]){
            string label;
            label = v[3];
            // cout<<"lund";
            jump(label);
            return;
        }
        else{
            //  cout<<"lund";
        }
        
    } 
    else if(opcode == "j" || opcode == "jump"){
        string label;
        label = v[1];
        jump(label);
        return;
    } 
    if(opcode==".data")
        {
            pc += 1;
            while(pc < newmemory.size() && newmemory[pc] != ".text")
            {
                
                string line1 = newmemory[pc];
                string opcode1, opcode2;
                std::istringstream iss1(line1);
                iss1 >> opcode1 >>opcode2;
                
                cout<<opcode1<<" "<<opcode2;
                if(opcode2==".word")
                {
                    int count=0;
                    int x;
                    int memsize = 0;
                    for(int i=0; i<1024; i++)
                    {
                        if(i==0){
                            unsigned long long int lund = reinterpret_cast< unsigned long long int>(memory);
                            // n.insert({temp,lund});
                        }
                        if(memory[i]!=0)
                        {
                            memsize++;
                        }

                    }
                    printf("%d\n",&memory[0]);
                    //  cout<<n[temp]<<endl;
                    while(iss1 >> x)
                    { 
                        cout<<x<<endl;
                        memory[count] = x;
                        cout<<memory[0]<<endl;
                        // if(count==1)
                        // {

                        //     info.push_back({opcode1.substr(0, opcode1.size() - 1),memsize});
                        //     cout<<"fuckof"<<endl;
                        // }

                        count++;
                        // memory.push_back(x);
                    }
                }

                pc++;
               
            }    
        } 
}


    void jump(const string& label) {
        pc = mnew[label];
    }
};


class processor {
private:
    std::vector<core> cores;
    int *memory;
    int clock;

public:
    processor() {
        cores.resize(2); // Create two cores
        core c1;
        memory = new int[1024];
        c1 = cores[0]; // Assign the first core
        clock = 0;
        printf("%d\n",&memory[0]);
    }

    void independentRun() {
        string instruction = cores[0].independentInstructionFetch();
        while (!instruction.empty()) {
            vector<string> decodedInstruction = cores[0].independentInstructionDecode(instruction);
            cores[0].independentExecute(decodedInstruction, memory);
            instruction = cores[0].independentInstructionFetch();
        }
        for(int i=0;i<1024;++i)
        {
            cout<<memory[i]<<" ";
        }
        cout<<endl;
        for(int i =0;i<32;++i)
        {
            cout<<cores[0].x[i]<<" ";
        }
    }
};

int main() {
    processor p;
    p.independentRun(); // Start the execution of the processor
    
    return 0;
}
